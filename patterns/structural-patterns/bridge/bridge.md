- 继承的麻烦
    - 对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。
    - 子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。
    - 这种依赖关系限制了灵活性并最终限制了复用性[DP]
- 合成／聚合复用原则。即优先使用对象合成／聚合，而不是类继承[DP]
  - 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物[DP]

- 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- 桥接模式就是为了避免直接继承带来的子类爆炸。
- 结构
  - ![](./structure-en-2x.png)
- 实例：很多电子设备有开关，切换频道，增加音量等功能，如电视，收音机等。
  - ![](./example-en-2x.png)
  - 对应结构
    - Abstraction 抽象：电子设备（支持开关，切换频道）
    - Refined abstraction 抽象细化：电视机，收音机
    - Implementation 实现：遥控器
    - Concrete implementation 具体实现：普通遥控器，高级遥控器，万能遥控器
  - 如果不想使用这种设计模式，那设计的时候假如有
    - 3个设备小米电视，华为电视，海尔电视
    - 2个遥控器普通遥控器，高级遥控器。
    - 2种电池纽扣电池，5号电池
    - 一共需要定义3*2*2=12个类型的遥控器。
    - 通过桥接模式只需要定义 3+2+2=7 7个类型